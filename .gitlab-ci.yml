workflow:
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "production"


variables:
  IMAGE_NAME: $CI_REGISTRY_IMAGE
  DEV_SERVER_HOST: 65.21.148.255
  DEV_ENDPOINT: 65.21.148.255

  PROD_SERVER_HOST: 91.107.197.9
  PROD_ENDPOINT: https://app.easynect.com


stages:
  - test
  - build_dev
  - build_prod
  - deploy_dev
  - deploy_staging
  - deploy_prod


build_dev_image:
  stage: build_dev
  tags:
    - shell
    - hertzner
  before_script:
    - export PACKAGE_JSON_VERSION=$(cat package.json | jq -r .version)
    - export VERSION=$PACKAGE_JSON_VERSION.$CI_PIPELINE_IID
    - echo $VERSION > version-file.txt
    - cp ${ENV_DEV} ./.env.production

  script:
    - docker build -f Dockerfile.dev -t $IMAGE_NAME:$VERSION .
  artifacts:
    paths:
      - version-file.txt
  only:
    - main

push_dev_image:
  stage: build_dev
  dependencies:
    - build_dev_image
  needs:
    - build_dev_image
  tags:
    - shell
    - hertzner
  before_script:
    - export VERSION=$(cat version-file.txt)
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker push $IMAGE_NAME:$VERSION
  
  only:
    - main


dev_deploy:
  stage: deploy_dev
  tags:
    - shell
    - hertzner
  dependencies:
    - build_dev_image
  variables:
    SSH_KEY: $PRIVATE_SSH_KEY
    SERVER_HOST: $DEV_SERVER_HOST

  before_script:
    - echo $SSH_KEY | sed -e "s/-----BEGIN OPENSSH PRIVATE KEY-----/&\n/" -e "s/-----END OPENSSH PRIVATE KEY-----/\n&/" -e "s/\S\{64\}/&\n/g"\ > deploy-key.pem
    - chmod 400 deploy-key.pem
    - export VERSION=$(cat version-file.txt)

  script:
    - scp -o StrictHostKeyChecking=no -i deploy-key.pem ./docker-compose-dev.yml root@$SERVER_HOST:/home/easynect/
    - ssh -o StrictHostKeyChecking=no -i deploy-key.pem root@$SERVER_HOST  "
      docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY &&
            cd /home/easynect/ &&
            export DC_IMAGE_NAME=$IMAGE_NAME && 
            export DC_IMAGE_TAG=$VERSION &&
            docker-compose -f docker-compose.yml down &&
            docker-compose -f docker-compose.yml up -d
        "
  only: 
    - main 


build_prod_image:
  stage: build_prod
  tags:
    - shell
    - hertzner
  before_script:
    - export PACKAGE_JSON_VERSION=$(cat package.json | jq -r .version)
    - export VERSION=$PACKAGE_JSON_VERSION.$CI_PIPELINE_IID
    - echo $VERSION > version-file.txt
    - cp ${ENV_PROD} ./.env.production

  script:
    - docker build -f Dockerfile -t $IMAGE_NAME:$VERSION .
  artifacts:
    paths:
      - version-file.txt
  only:
    - production

push_prod_image:
  stage: build_prod
  dependencies:
    - build_prod_image
  needs:
    - build_prod_image
  tags:
    - shell
    - hertzner
  before_script:
    - export VERSION=$(cat version-file.txt)
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker push $IMAGE_NAME:$VERSION
  
  only:
    - production


prod_deploy:
  stage: deploy_prod
  tags:
    - shell
    - hertzner
  dependencies:
    - build_prod_image
  variables:
    SSH_KEY: $PRIVATE_SSH_KEY
    SERVER_HOST: $PROD_SERVER_HOST

  before_script:
    - echo $SSH_KEY | sed -e "s/-----BEGIN OPENSSH PRIVATE KEY-----/&\n/" -e "s/-----END OPENSSH PRIVATE KEY-----/\n&/" -e "s/\S\{64\}/&\n/g"\ > deploy-key.pem
    - chmod 400 deploy-key.pem
    - export VERSION=$(cat version-file.txt)

  script:
    - scp -o StrictHostKeyChecking=no -i deploy-key.pem ./docker-compose.yml root@$SERVER_HOST:/home/frontend/user/
    - ssh -o StrictHostKeyChecking=no -i deploy-key.pem root@$SERVER_HOST  "
      docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY &&
            cd /home/frontend/user/ &&
            export DC_IMAGE_NAME=$IMAGE_NAME && 
            export DC_IMAGE_TAG=$VERSION &&
            docker-compose -f docker-compose.yml down &&
            docker-compose -f docker-compose.yml up -d
        "
  only: 
    - production 